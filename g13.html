<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense | Infinite Arcade</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&family=Inter:wght@400;600&display=swap"
        rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --bg: #020617;
            --surface: rgba(15, 23, 42, .8);
            --border: rgba(255, 255, 255, .08);
            --accent: #6366f1
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            background: var(--bg);
            color: #f8fafc;
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #94a3b8;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: .9rem;
            z-index: 99;
            transition: .2s
        }

        .back-btn:hover {
            color: #fff
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            padding: 60px 20px 20px
        }

        h1 {
            font-family: 'Outfit', sans-serif;
            font-size: 2rem;
            font-weight: 900;
            background: linear-gradient(135deg, #c7d2fe, #6366f1);
            -webkit-background-clip: text; background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center
        }

        .hud {
            display: flex;
            gap: 12px;
            width: 100%;
            max-width: 600px;
            justify-content: center
        }

        .stat {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px 14px;
            text-align: center;
            flex: 1
        }

        .stat-label {
            font-size: .65rem;
            text-transform: uppercase;
            letter-spacing: .1em;
            color: #64748b
        }

        .stat-val {
            font-family: 'Outfit', sans-serif;
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--accent)
        }

        .game-area {
            display: flex;
            gap: 16px;
            align-items: flex-start
        }

        .canvas-wrap {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(99, 102, 241, .2);
            box-shadow: 0 0 40px rgba(99, 102, 241, .1)
        }

        canvas {
            display: block;
            background: #0f172a;
            cursor: crosshair
        }

        .shop {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 160px
        }

        .shop-item {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: .2s;
            text-align: center
        }

        .shop-item.active {
            border-color: var(--accent);
            background: rgba(99, 102, 241, .15);
            box-shadow: 0 0 16px rgba(99, 102, 241, .2)
        }

        .shop-item.disabled {
            opacity: .4;
            cursor: not-allowed
        }

        .shop-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            margin: 0 auto 8px;
            display: flex;
            align-items: center;
            justify-content: center
        }

        .shop-name {
            font-weight: 700;
            font-size: .9rem;
            font-family: 'Outfit'
        }

        .shop-cost {
            font-size: .8rem;
            color: #fbbf24;
            font-weight: 600
        }

        .shop-stats {
            font-size: .7rem;
            color: #94a3b8;
            margin-top: 4px;
            line-height: 1.4
        }

        .overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(2, 6, 23, .92);
            backdrop-filter: blur(8px);
            gap: 16px;
            z-index: 10
        }

        .overlay.hidden {
            display: none
        }

        .overlay h2 {
            font-family: 'Outfit', sans-serif;
            font-size: 2.5rem;
            font-weight: 900
        }

        .btn-primary {
            padding: 12px 32px;
            border-radius: 12px;
            border: none;
            background: linear-gradient(135deg, #818cf8, #4f46e5);
            color: #fff;
            font-weight: 900;
            cursor: pointer;
            font-size: 1.1rem;
            font-family: 'Outfit', sans-serif;
            transition: .2s
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(79, 70, 229, .3)
        }
    </style>
</head>

<body>
    <a href="index.html" class="back-btn"><i class="fas fa-arrow-left"></i> Hub</a>

    <div class="container">
        <h1>ðŸ›¡ Tower Defense</h1>

        <div class="hud">
            <div class="stat">
                <div class="stat-label">Wave</div>
                <div class="stat-val" id="wave">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">Lives</div>
                <div class="stat-val" id="lives" style="color:#ef4444">20</div>
            </div>
            <div class="stat">
                <div class="stat-label">Gold</div>
                <div class="stat-val" id="gold" style="color:#fbbf24">100</div>
            </div>
            <div class="stat">
                <div class="stat-label">Score</div>
                <div class="stat-val" id="score">0</div>
            </div>
        </div>

        <div class="game-area">
            <div class="canvas-wrap">
                <canvas id="c" width="600" height="480"></canvas>
                <div class="overlay" id="overlay">
                    <h2 id="ovTitle">Defend the Base!</h2>
                    <p id="ovDesc" style="color:#94a3b8;margin-bottom:8px">Build towers to stop the incoming enemies.
                    </p>
                    <button class="btn-primary" id="startBtn">â–¶ Start Wave 1</button>
                </div>
            </div>

            <div class="shop">
                <div class="shop-item active" id="buy-basic" data-type="basic">
                    <div class="shop-icon" style="background:#3b82f6"><i class="fas fa-bullseye"></i></div>
                    <div class="shop-name">Basic Turret</div>
                    <div class="shop-cost">50 Gold</div>
                    <div class="shop-stats">Dmg: 10<br>Range: 100</div>
                </div>
                <div class="shop-item" id="buy-sniper" data-type="sniper">
                    <div class="shop-icon" style="background:#a855f7"><i class="fas fa-crosshairs"></i></div>
                    <div class="shop-name">Sniper</div>
                    <div class="shop-cost">120 Gold</div>
                    <div class="shop-stats">Dmg: 40<br>Range: 200</div>
                </div>
                <div class="shop-item" id="buy-rapid" data-type="rapid">
                    <div class="shop-icon" style="background:#f59e0b"><i class="fas fa-bolt"></i></div>
                    <div class="shop-name">Rapid Fire</div>
                    <div class="shop-cost">150 Gold</div>
                    <div class="shop-stats">Dmg: 5<br>Speed: Fast</div>
                </div>
                <div class="shop-item" id="buy-sell" data-type="sell"
                    style="margin-top:auto;border-color:#ef4444;background:rgba(239,68,68,.1)">
                    <div class="shop-icon" style="background:#ef4444;color:#fff"><i class="fas fa-trash"></i></div>
                    <div class="shop-name">Sell Tower</div>
                    <div class="shop-stats">Returns 50%</div>
                </div>
            </div>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
        const W = 600, H = 480;
        const TS = 40; // Tile size
        const COLS = W / TS, ROWS = H / TS;

        // Map config (0: buildable, 1: path, 2: base)
        const map = [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ];
        const pathPts = [];
        // Parse path points
        let currX = 0, currY = 1;
        pathPts.push({ x: currX * TS + TS / 2, y: currY * TS + TS / 2 });
        let visited = new Set([`0,1`]);
        while (map[currY][currX] !== 2) {
            let found = false;
            [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                if (found) return;
                let nx = currX + dx, ny = currY + dy;
                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && (map[ny][nx] === 1 || map[ny][nx] === 2) && !visited.has(`${nx},${ny}`)) {
                    visited.add(`${nx},${ny}`);
                    pathPts.push({ x: nx * TS + TS / 2, y: ny * TS + TS / 2 });
                    currX = nx; currY = ny; found = true;
                }
            });
            if (!found) break;
        }

        // Stats & Towers
        const TOWER_TYPES = {
            basic: { cost: 50, range: 100, dmg: 10, cd: 40, color: '#3b82f6' },
            sniper: { cost: 120, range: 240, dmg: 40, cd: 90, color: '#a855f7' },
            rapid: { cost: 150, range: 85, dmg: 5, cd: 8, color: '#f59e0b' }
        };

        let gold = 100, lives = 20, wave = 1, score = 0;
        let buildMode = 'basic'; // basic|sniper|rapid|sell
        let towers = [], enemies = [], projectiles = [], particles = [];
        let reqId, running = false, waiting = true, waveSpawned = 0, waveEnemies = 0, spawnTimer = 0;
        let mx = -100, my = -100;

        document.querySelectorAll('.shop-item').forEach(el => {
            el.onclick = () => {
                document.querySelectorAll('.shop-item').forEach(e => e.classList.remove('active'));
                el.classList.add('active');
                buildMode = el.dataset.type;
            }
        });

        function updateHUD() {
            document.getElementById('gold').textContent = gold;
            document.getElementById('lives').textContent = lives;
            document.getElementById('wave').textContent = wave;
            document.getElementById('score').textContent = score;

            ['basic', 'sniper', 'rapid'].forEach(t => {
                const el = document.getElementById(`buy-${t}`);
                if (gold < TOWER_TYPES[t].cost) el.classList.add('disabled');
                else el.classList.remove('disabled');
            });
        }

        function startWave() {
            running = true; waiting = false;
            document.getElementById('overlay').classList.add('hidden');
            waveSpawned = 0; waveEnemies = 5 + wave * 3; spawnTimer = 0;
            cancelAnimationFrame(reqId);
            update();
        }
        document.getElementById('startBtn').onclick = () => {
            if (lives <= 0) { gold = 100; lives = 20; wave = 1; score = 0; towers = []; enemies = []; projectiles = []; particles = []; }
            startWave();
        };

        function spawnEnemy() {
            const hpBase = 20 + wave * 15;
            const isFast = Math.random() < 0.2 + wave * 0.02;
            const isTank = Math.random() < 0.1 + wave * 0.01 && !isFast;

            let hp = hpBase, spd = 1.2 + wave * 0.05, r = 8, color = '#ef4444', reward = 5;
            if (isFast) { hp = hpBase * 0.6; spd *= 1.8; r = 6; color = '#fcd34d'; reward = 6; }
            else if (isTank) { hp = hpBase * 3; spd *= 0.6; r = 12; color = '#b91c1c'; reward = 12; }

            enemies.push({ x: pathPts[0].x, y: pathPts[0].y, pathIdx: 0, hp, maxHp: hp, spd, r, color, reward });
            waveSpawned++;
        }

        function updateMousePos(cX, cY) {
            const rect = canvas.getBoundingClientRect();
            mx = (cX - rect.left) * (W / rect.width);
            my = (cY - rect.top) * (H / rect.height);
        }

        canvas.addEventListener('mousemove', e => updateMousePos(e.clientX, e.clientY));
        canvas.addEventListener('mouseleave', () => { mx = -100; my = -100; });

        canvas.addEventListener('touchstart', e => {
            if (e.touches.length > 0) updateMousePos(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: true });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length > 0) updateMousePos(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        canvas.addEventListener('click', () => {
            if (!running && waiting) return;
            const tx = Math.floor(mx / TS), ty = Math.floor(my / TS);
            if (tx < 0 || tx >= COLS || ty < 0 || ty >= ROWS) return;

            // Check if tower exists here
            const existIdx = towers.findIndex(t => t.tx === tx && t.ty === ty);

            if (buildMode === 'sell') {
                if (existIdx !== -1) {
                    gold += Math.floor(towers[existIdx].cost * 0.5);
                    towers.splice(existIdx, 1);
                    burst(tx * TS + TS / 2, ty * TS + TS / 2, '#fbbf24', 10);
                    updateHUD();
                }
            } else {
                // Build
                if (map[ty][tx] === 0 && existIdx === -1) {
                    const type = TOWER_TYPES[buildMode];
                    if (gold >= type.cost) {
                        gold -= type.cost;
                        towers.push({ tx, ty, cx: tx * TS + TS / 2, cy: ty * TS + TS / 2, angle: 0, timer: 0, ...type });
                        burst(tx * TS + TS / 2, ty * TS + TS / 2, type.color, 10);
                        updateHUD();
                    }
                }
            }
        });

        function burst(x, y, color, count) {
            for (let i = 0; i < count; i++) particles.push({ x, y, vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5, life: 1, color, r: Math.random() * 2 + 1 });
        }

        function update() {
            if (!running) return;

            // Spawn
            if (!waiting && waveSpawned < waveEnemies) {
                if (spawnTimer <= 0) { spawnEnemy(); spawnTimer = 60 - Math.min(40, wave * 2); }
                else spawnTimer--;
            }

            // Enemies
            enemies.forEach((e, i) => {
                const target = pathPts[e.pathIdx + 1];
                if (!target) {
                    // Reached base
                    enemies.splice(i, 1); lives--; updateHUD();
                    burst(e.x, e.y, e.color, 15);
                    if (lives <= 0) {
                        running = false; document.getElementById('ovTitle').textContent = 'Game Over';
                        document.getElementById('startBtn').textContent = 'Restart';
                        document.getElementById('overlay').classList.remove('hidden');
                    }
                    return;
                }
                const ang = Math.atan2(target.y - e.y, target.x - e.x);
                e.x += Math.cos(ang) * e.spd; e.y += Math.sin(ang) * e.spd;
                if (Math.hypot(target.x - e.x, target.y - e.y) < e.spd) e.pathIdx++;
            });

            // Towers
            towers.forEach(t => {
                if (t.timer > 0) t.timer--;

                // Find target
                let target = null, minDist = t.range;
                enemies.forEach(e => {
                    const d = Math.hypot(e.x - t.cx, e.y - t.cy);
                    if (d <= minDist) { target = e; minDist = d; }
                });

                if (target) {
                    t.angle = Math.atan2(target.y - t.cy, target.x - t.cx);
                    if (t.timer <= 0) {
                        t.timer = t.cd;
                        projectiles.push({ x: t.cx, y: t.cy, vx: Math.cos(t.angle) * 8, vy: Math.sin(t.angle) * 8, dmg: t.dmg, target, color: t.color });
                    }
                }
            });

            // Projectiles
            projectiles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy;

                // Check hit
                if (p.target && enemies.includes(p.target)) {
                    if (Math.hypot(p.target.x - p.x, p.target.y - p.y) < p.target.r + 5) {
                        projectiles.splice(i, 1);
                        p.target.hp -= p.dmg;
                        burst(p.target.x, p.target.y, p.color, 4);
                        if (p.target.hp <= 0) {
                            gold += p.target.reward; score += p.target.reward * 10; updateHUD();
                            burst(p.target.x, p.target.y, p.target.color, 10);
                            enemies.splice(enemies.indexOf(p.target), 1);
                        }
                    }
                } else {
                    // Target died, fly off map
                    if (p.x < 0 || p.x > W || p.y < 0 || p.y > H) projectiles.splice(i, 1);
                }
            });

            // Particles
            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy; p.life -= 0.05;
                if (p.life <= 0) particles.splice(i, 1);
            });

            // Wave check
            if (!waiting && waveSpawned >= waveEnemies && enemies.length === 0 && lives > 0) {
                waiting = true; wave++; gold += 50 + wave * 10; updateHUD();
                document.getElementById('ovTitle').textContent = `Wave ${wave - 1} Cleared!`;
                document.getElementById('startBtn').textContent = `Start Wave ${wave}`;
                document.getElementById('overlay').classList.remove('hidden');
            }

            draw();
            reqId = requestAnimationFrame(update);
        }

        function draw() {
            ctx.fillStyle = '#020617'; ctx.fillRect(0, 0, W, H);

            // Map
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (map[y][x] === 1) { ctx.fillStyle = '#1e293b'; ctx.fillRect(x * TS, y * TS, TS, TS); }
                    if (map[y][x] === 2) { ctx.fillStyle = '#334155'; ctx.fillRect(x * TS, y * TS, TS, TS); ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.arc(x * TS + TS / 2, y * TS + TS / 2, 12, 0, Math.PI * 2); ctx.fill(); }
                }
            }

            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = 0; x <= W; x += TS) { ctx.moveTo(x, 0); ctx.lineTo(x, H); }
            for (let y = 0; y <= H; y += TS) { ctx.moveTo(0, y); ctx.lineTo(W, y); }
            ctx.stroke();

            // Highlight tile
            const tx = Math.floor(mx / TS), ty = Math.floor(my / TS);
            if (tx >= 0 && tx < COLS && ty >= 0 && ty < ROWS) {
                if (buildMode === 'sell') {
                    ctx.fillStyle = 'rgba(239,68,68,0.3)'; ctx.fillRect(tx * TS, ty * TS, TS, TS);
                } else {
                    if (map[ty][tx] === 0 && !towers.some(t => t.tx === tx && t.ty === ty)) {
                        ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fillRect(tx * TS, ty * TS, TS, TS);
                        ctx.beginPath(); ctx.arc(tx * TS + TS / 2, ty * TS + TS / 2, TOWER_TYPES[buildMode].range, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.fill(); ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.stroke();
                    } else {
                        ctx.fillStyle = 'rgba(239,68,68,0.3)'; ctx.fillRect(tx * TS, ty * TS, TS, TS);
                    }
                }
            }

            // Towers
            towers.forEach(t => {
                // Base
                ctx.fillStyle = '#334155'; ctx.fillRect(t.tx * TS + 4, t.ty * TS + 4, TS - 8, TS - 8);
                // Turret
                ctx.save(); ctx.translate(t.cx, t.cy); ctx.rotate(t.angle);
                ctx.fillStyle = t.color;
                ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                ctx.fillRect(0, -4, 16, 8);
                ctx.restore();
            });

            // Projectiles
            projectiles.forEach(p => {
                ctx.fillStyle = '#fff'; ctx.shadowColor = p.color; ctx.shadowBlur = 8;
                ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            });

            // Enemies
            enemies.forEach(e => {
                ctx.fillStyle = e.color;
                ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2); ctx.fill();
                // HP bar
                ctx.fillStyle = '#ef4444'; ctx.fillRect(e.x - 10, e.y - e.r - 6, 20, 3);
                ctx.fillStyle = '#22c55e'; ctx.fillRect(e.x - 10, e.y - e.r - 6, 20 * (e.hp / e.maxHp), 3);
            });

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;

        }

        draw();
        updateHUD();

    </script>
</body>

</html>
